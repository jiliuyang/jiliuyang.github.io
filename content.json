{"pages":[],"posts":[{"title":"深拷贝和浅拷贝","text":"在项目中初次碰到深拷贝和浅拷贝的问题场景是这样的：一个数据注册的信息初始化模板（注册字段比较多），在初始化页面是需要拷贝这个信息模板来初始化页面，本来复制一下是没什么的，但鉴于中间某些操作需要再次使用该信息模板，但因为之前拷贝后对部分值做了修改，导致原信息模板值也同时发生了改变，这才发现拷贝是存在深拷贝和浅拷贝的区别的。 深拷贝和浅拷贝的区别在哪里呢？在介绍深浅拷贝的区别之前，我们先讲解几个前置概念，方便我们更好的理解深浅拷贝的差异。 一、数据类型的分类js的数据类型大体分为两类： 121、基础数据类型：Number,String,Undefined,Null,Boolean,Symbol。这些类型的数据可以直接操作保存在变量中的实际值。2、引用数据类型：Object，Array,Function，可以说除了基础数据类型之外的都属于引用数据类型。 二、栈和堆栈会自动分配内存空间，且会自动释放，它的空间大小是固定的，一般用来存放基础数据类型，简单的数据段。 堆是动态分配的内存空间，大小不固定且不会自动释放。一般用来存放引用数据类型。 我们看下面的一个例子: 123456let a = [1, 2, 3, 4, 5]let b = a;let c = a[0];b[1] = 100;c = 20;console.log(a); //[1,100,3,4,5] 结合上例打印结果可知：a是一个数组，属于引用数据类型，将其赋值给b，实际上是将其引用地址拷贝一份传给了b并存放到栈中，而真实的数组对象则是存放在堆中，系统通过引用地址（或者说指针）来快速查找保存到堆内存中的对象，所以修改数组b就等同于修原数组a。而c只是从a的堆内存中获取了几个基础类型数据拷贝给a,然后将该备份存放到栈内存中，此时该备份与原数据是相互独立的个体，修改c将直接修改栈内存中的值，与a无关。 总的来说就是：简单数据类型直接储存在栈内存中，可以直接访问并对其进行修改；而引用数据类型则是存放在堆内存中，保存在栈内存中的变量其实是一个引用地址（或者说指针）,该指针指向堆内存中存放的对象数据，可以通过指针来查找保存在堆内存中的对象。而拷贝引用数据类型就是拷贝指针，因为拷贝后的指针指向的是同一个对象，所以修改任何一个变量都会修改堆内存中的对象。 如果上述语言过于文字化，我们再举个例子：栈内存就好比一个书橱，每个格子里面存放一本书（也就是基础类型数据），我们要拷贝一份就好比重新印刷一本然后放到下一个空格子里面，二者相互独立，互不相干。堆内存就好比一个大仓库，这些仓库又分许多区，区的大小不一致，每个区都存放某一类书籍，数量不固定，种类不固定(好比引用数据类型的对象和或数组，大小不确定)。为了给对应的区进行分类，我们给每个区一个编号球，然后将编号球放在书橱里，想去查找仓库某个区的书籍时就通过编号快速查询。而拷贝引用数据类型，鉴于其占用内存的大小说不准，为了节约空间，我们就把其编号球复制一个，放到新的书格子里，这样因为他们对应共同的区编号，都可以找到并查看区里的书籍。这样是不是就很好理解了？ 讲了上面2个概念，我们再回头来看深拷贝和浅拷贝，就不会显得没有头绪了。 所谓浅拷贝就是仅仅拷贝基本数据类型，而对于引用数据类型，因为拷贝的只是其引用地址，拷贝后的引用类型数据源发生改变，就意味着原数据源也同时发生了改变。 而深拷贝就是拷贝之后相当于重新开辟出一个内存空间来存放复制的对象，二者相互独立，内容相同但各自占用一个独立内存空间。 常见的浅拷贝方法1、slice大家知道slice()方法可以用来操作一个数组从中截取一段数据形成一个新数组返回。如果不传值，则相当于复制了一个相同的数组并返回。如下所示： 1234let a = [1,2,3,4,5];let b = a.slice();b[0] = 100;console.log(a); //[1,2,3,4,5] 2、concatconcat()也是数组的一个处理方法，用于将两个或多个数组拼接为一个新的数组并返回，而不会改变原数组。如下所示： 1234let a = [1,2,3,4,5];let b = a.concat();b[0] = 100;console.log(a); //[1,2,3,4,5] 3、遍历数组的各项元素，组成一个新数组，这个就不做详述。备注：以上方法都是数组的拷贝，下面2个是对象的拷贝。 4、Object.assign()Object.assign()方法用于合并对象，即将所有可枚举属性的值从一个或多个源对象复制到目标对象，最终返回目标对象。 如果源对象中有和目标对象同名的属性，则后者会覆盖前者，例如： 123456const o1 = { a: 1, b: 1, c: 1 };const o2 = { b: 2, c: 2 };const o3 = { c: 3 };const obj = Object.assign({}, o1, o2, o3);console.log(obj); // { a: 1, b: 2, c: 3 } 但鉴于Object.assign()拷贝时拷贝的是属性值，假如源对象的属性值是一个对象的引用，那么它只能指向那个引用。所以它不能实现深拷贝。 5、扩展运算符扩展运算符可以在函数调用和数组构造时，将数组表达式和string在语法层面上展开，或将对象以key-value的形式展开来。 12345678910//示例一let a = [1,2,3];function add(x,y,z){ return x+y+z}console.log(add(...a)); //6//示例二let c = [...a]; //也可以实现数组的复制let d = {...{a:1,b:2}} //可以实现对象的复制 但如果上述数组和对象中的属性包含其他数组或对象时，这时候复制的依旧是其对应引用地址，所以也无法实现深拷贝。 如何实现深拷贝？1、最通用的方法就是下面这种： 1JSON.parse(JSON.stringify(obj)) 该方法可以轻松的实现深拷贝。2、鉴于上面列举的方法无法实现深拷贝的原因是对于引用类型的数据无法直接拷贝值而是拷贝其引用地址，那么我们对每个引用类型的数据做层层循环遍历处理，也可以达到深拷贝的目的，以下是网上提供的方法： 1234567891011function copy (obj) { var newobj = obj.constructor === Array ? [] : {}; if(typeof obj !== &apos;object&apos;){ return; } for(var i in obj){ newobj[i] = typeof obj[i] === &apos;object&apos; ? copy(obj[i]) : obj[i]; } return newobj} 总结最后我们要知道：深拷贝实际上是很耗性能的，因为它将会把原对象的内容进行复制然后开辟出一块全新的内存空间来进行存放，这样如果对象数据量大而拷贝次数过多，对性能就会产生影响。","link":"/2019/10/31/copy-sum/"},{"title":"我的第一篇测试博客","text":"挑剑试问心所向，万事只有开头难！ 岱宗夫如何，齐鲁青未了。造化钟神秀，阴阳割分晓。","link":"/2019/10/30/test/"},{"title":"ES6常见数组处理方法分析汇总","text":"事先给出一个以下方法要遍历的数组对象： 1234567const arr = [ {name:&quot;黄药师&quot;,alias:&quot;东邪&quot;,age:66}, {name:&quot;欧阳锋&quot;,alias:&quot;西毒&quot;,age:66}, {name:&quot;段皇爷&quot;,alias:&quot;南帝&quot;,age:76}, {name:&quot;洪七公&quot;,alias:&quot;北丐&quot;,age:72}, {name:&quot;王重阳&quot;,alias:&quot;中神通&quot;,age:80}]; 一、遍历数组元素进行某种逻辑判断返回布尔值的数组方法1、array.every()every方法用来检测数组中的每一项元素是否都通过了某一条件判断，通过则返回true，反之返回false 1234const flag = arr.every(item =&gt; { return item.age === 66})console.log(flag) //false 2、array.some()some方法用来检测数组中是否存在至少一项元素满足某一条件判断，存在则返回true，反之则返回false 1234const flag = arr.some(item =&gt; { return item.alias === &quot;北丐&quot;})console.log(flag) //true 3、array.includes(element,fromIndex)includes方法用来判断数组内是否包含某一个指定值，且可以指定从数组某一个索引值开始检索。其中element是要检索的元素，fromIndex是开始检索的索引值。 12const flag = [1,2,3,5].includes(5,2);console.log(flag) //true 二、遍历数组元素并返回一个新数组4、array.map()map方法用来遍历数组中的每一个元素，然后对其做同一处理，返回新的元素最终组合成一个新数组返回。 12345const arr1 = arr.map(item =&gt; { return {alias: `五绝之${item.alias}`}})console.log(arr1) /* [{alias:&quot;五绝之东邪&quot;},{alias:&quot;五绝之西毒&quot;},{alias:&quot;五绝之南帝&quot;},{alias:&quot;五绝之北丐&quot;},{alias:&quot;五绝之中神通&quot;}] */ 5、array.filter()filter方法用来遍历数组中的每一项元素，然后执行同一判断条件的检测后过滤出满足条件的元素值最终组合成新的数组返回。 1234const arr1 = arr.filter(item =&gt; { return item.name === &quot;洪七公&quot;})console.log(arr1); //[{name:&quot;洪七公&quot;,alias:&quot;北丐&quot;,age:72}] 三、数组处理的增删改查6、array.pop()和array.shift()pop方法用来删除数组的最后一个元素，并返回最后一个元素的值。备注：数组为空时则返回undefined 1234const newArr = [1,2,3,4,5];const val = newArr.pop();console.log(newArr); //[1,2,3,4]console.log(val); //5 shift方法用来删除数组的第一个元素，并返回第一个元素的值。备注：数组为空时则返回undefined 1234const newArr = [1,2,3,4,5];const val = newArr.shift();console.log(newArr); //[2,3,4,5]console.log(val); //1 7、array.push(element1,element2,…,elementN)和array.unshift(element1,element2,…,elementN)push方法用来将一个或多个元素依次添加到数组的末尾，并返回新数组的长度。 1234const arr = [1,2,3,4];const len = arr5.unshift(9,8);console.log(arr) //[9,8,1,2,3,4]console.log(len) //6 unshift方法用来将一个或多个元素依次添加到数组的开头，并返回新数组的长度。 1234const arr = [1,2,3,4];const len = arr5.unshift(9,8);console.log(arr) //[1,2,3,4,9,8]console.log(len) //6 8、array.splice(startIndex,deleteItemNum,item1,item2,…,itemN)splice方法可以实现对数组进行增删的操作并返回被删除的项所组成的数组，其中startIndex（必需）是规定要添加/删除元素的位置，若未负数则从末尾处开始；deleteItemNum是要删除的元素个数，若为0则不删除；itemN(非必需)为要新增的元素，插入位置即startIndex位置。 1234567const arr6 = [1,2,3,4,5,6,7];const result = arr6.splice(2,2,&quot;a&quot;,&quot;b&quot;);console.log(arr6); //[1,2,&quot;a&quot;,&quot;b&quot;,5,6,7]console.log(result); //[3,4]const result1 = arr6.splice(-2,1,&quot;c&quot;);console.log(arr6); //[1,2,&quot;a&quot;,&quot;b&quot;,5,&quot;c&quot;,7]console.log(result1); //[6] 9、array.indexOf(element,fromIndex)和array.findIndex()indexOf方法可以返回数组中匹配到的给定元素的第一个索引值，若不存在则返回-1。其中element是要匹配的指定元素，fromIndex为开始执行匹配检索的索引位置。 12345const idx = [1,2,3,4,5].indexOf(6);const idx1 = arr.indexOf({name:&quot;洪七公&quot;,alias:&quot;北丐&quot;,age:72})console.log(idx); //-1console.log(idx1); //-1 我们发现对于复杂的对象数组，indexOf是无法进行索引位置查找的 findIndex方法与indexOf方法的作用类似，但更高级，一般用来处理一些复杂的对象数组，查找到则返回第一个匹配元素的索引，反之则返回-1. 1234const idx = arr.findIndex(item =&gt; { return item.name === &quot;洪七公&quot;})console.log(idx) //3 数组的其他处理方法10、array.reverse()reverse方法用来翻转原数组的先后顺序 123const arr = [1,2,3,4,5];arr.reverse();console.log(arr) //[5,4,3,2,1] 11、array.join()join方法用来将数组中的各项元素用某一指定的字符串进行拼接，返回一个新的字符串。 123cosnt arr = [1992,01,12];arr.join(&quot;-&quot;);console.log(arr) //&quot;1992-01-12&quot; 12、array.concat(arr1,arr2,…,arrN)concat为数组拼接方法，可将多个数组进行拼接，最终返回一个新数组，原数组没有改变。 1234const arr = [1,2];const newArr = arr.concat([&quot;a&quot;,&quot;b&quot;],[9,8]);console.log(newArr); //[1,2,&quot;a&quot;,&quot;b&quot;,9,8]console.log(arr); //[1,2] 13、array.sort([copareFunction])sort方法可以对数组按某一指定比较规则进行排序。如果不传参数则按照字符编码的顺序进行排序 14、array.reduce(function(prev,cur,indedx,arr),initialValue)reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。一般来说空数组是不会进行回调的，用空数组执行reduce方法时会报错，但如果设置了初始值则可以避免，但一般也不推荐(因为没有意义)。 initialValue是可自定义的初始值，如果设置了则以其作为初始值（此时起始所以为0），如果不设置则以数组的第一个元素作为初始值（此时起始索引为1）。如下面的2个累加计算示例可看出来 123456const arr = [1,2,3,4]const val = arr.reduce((prev,cur,index,arr) =&gt; { console.log(index) //依次为1,2,3 return prev + cur;})console.log(val) //10 123456const arr = [1,2,3,4]const val = arr.reduce((prev,cur,index,arr) =&gt; { console.log(index) //依次为0,1,2,3 return prev + cur;})console.log(val) //10 reduce方法可以说是一个高级方法，因为他的可自定义的累加器函数，可以处理很多比较高级的操作，常见的有： 数组去重123456789let arr = [1,2,3,3,1,2]let newArr = arr.reduce((pre,cur)=&gt;{ if(!pre.includes(cur)){ return pre.concat(cur) }else{ return pre }},[])console.log(newArr);// [1, 2, 3] 计算数组中各元素出现的次数1234567891011let characters = [&apos;a&apos;, &apos;b&apos;, &apos;t&apos;, &apos;t&apos;, &apos;a&apos;,&apos;f&apos;];let arr = characters.reduce((pre,cur)=&gt;{ if(cur in pre){ pre[cur]++ }else{ pre[cur] = 1 } return pre},{})console.log(arr); //{a: 2, b: 1, t: 2, f: 1} 对象数组中的单个属性累加12345678910const achievement = [ {year:&apos;2016年&apos;,number: 231200}, {year:&apos;2017年&apos;,number: 201900}, {year:&apos;2018年&apos;,number: 275678}, {year:&apos;2019年&apos;,number: 301200}];const sum = achievement.reduce((prev,cur) =&gt; { return prev + cur.number},0)console.log(sum) //1009978 将二维数组转化为一维数组12345let arr = [[0, 1], [2, 3], [4, 5]]let newArr = arr.reduce((pre,cur)=&gt;{ return pre.concat(cur)},[])console.log(newArr); // [0, 1, 2, 3, 4, 5] 将多维数组转化为一维数组12345let arr = [[0, 1], [2, 3], [4,[5,6,7]]]const newArr = function(arr){ return arr.reduce((pre,cur)=&gt;pre.concat(Array.isArray(cur)?newArr(cur):cur),[])}console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7]","link":"/2019/10/31/array-sum/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/10/29/hello-world/"}],"tags":[],"categories":[{"name":"原生JS","slug":"原生JS","link":"/categories/%E5%8E%9F%E7%94%9FJS/"},{"name":"闲散小记","slug":"闲散小记","link":"/categories/%E9%97%B2%E6%95%A3%E5%B0%8F%E8%AE%B0/"},{"name":"ES6","slug":"ES6","link":"/categories/ES6/"}]}