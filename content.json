{"pages":[],"posts":[{"title":"ES6常见数组处理方法分析汇总","text":"事先给出一个以下方法要遍历的数组对象： 1234567const arr = [ {name:&quot;黄药师&quot;,alias:&quot;东邪&quot;,age:66}, {name:&quot;欧阳锋&quot;,alias:&quot;西毒&quot;,age:66}, {name:&quot;段皇爷&quot;,alias:&quot;南帝&quot;,age:76}, {name:&quot;洪七公&quot;,alias:&quot;北丐&quot;,age:72}, {name:&quot;王重阳&quot;,alias:&quot;中神通&quot;,age:80}]; 一、遍历数组元素进行某种逻辑判断返回布尔值的数组方法1、array.every()every方法用来检测数组中的每一项元素是否都通过了某一条件判断，通过则返回true，反之返回false 1234const flag = arr.every(item =&gt; { return item.age === 66})console.log(flag) //false 2、array.some()some方法用来检测数组中是否存在至少一项元素满足某一条件判断，存在则返回true，反之则返回false 1234const flag = arr.some(item =&gt; { return item.alias === &quot;北丐&quot;})console.log(flag) //true 3、array.includes(element,fromIndex)includes方法用来判断数组内是否包含某一个指定值，且可以指定从数组某一个索引值开始检索。其中element是要检索的元素，fromIndex是开始检索的索引值。 12const flag = [1,2,3,5].includes(5,2);console.log(flag) //true 二、遍历数组元素并返回一个新数组4、array.map()map方法用来遍历数组中的每一个元素，然后对其做同一处理，返回新的元素最终组合成一个新数组返回。 12345const arr1 = arr.map(item =&gt; { return {alias: `五绝之${item.alias}`}})console.log(arr1) /* [{alias:&quot;五绝之东邪&quot;},{alias:&quot;五绝之西毒&quot;},{alias:&quot;五绝之南帝&quot;},{alias:&quot;五绝之北丐&quot;},{alias:&quot;五绝之中神通&quot;}] */ 5、array.filter()filter方法用来遍历数组中的每一项元素，然后执行同一判断条件的检测后过滤出满足条件的元素值最终组合成新的数组返回。 1234const arr1 = arr.filter(item =&gt; { return item.name === &quot;洪七公&quot;})console.log(arr1); //[{name:&quot;洪七公&quot;,alias:&quot;北丐&quot;,age:72}] 三、数组处理的增删改查6、array.pop()和array.shift()pop方法用来删除数组的最后一个元素，并返回最后一个元素的值。备注：数组为空时则返回undefined 1234const newArr = [1,2,3,4,5];const val = newArr.pop();console.log(newArr); //[1,2,3,4]console.log(val); //5 shift方法用来删除数组的第一个元素，并返回第一个元素的值。备注：数组为空时则返回undefined 1234const newArr = [1,2,3,4,5];const val = newArr.shift();console.log(newArr); //[2,3,4,5]console.log(val); //1 7、array.push(element1,element2,…,elementN)和array.unshift(element1,element2,…,elementN)push方法用来将一个或多个元素依次添加到数组的末尾，并返回新数组的长度。 1234const arr = [1,2,3,4];const len = arr5.unshift(9,8);console.log(arr) //[9,8,1,2,3,4]console.log(len) //6 unshift方法用来将一个或多个元素依次添加到数组的开头，并返回新数组的长度。 1234const arr = [1,2,3,4];const len = arr5.unshift(9,8);console.log(arr) //[1,2,3,4,9,8]console.log(len) //6 8、array.splice(startIndex,deleteItemNum,item1,item2,…,itemN)splice方法可以实现对数组进行增删的操作并返回被删除的项所组成的数组，其中startIndex（必需）是规定要添加/删除元素的位置，若未负数则从末尾处开始；deleteItemNum是要删除的元素个数，若为0则不删除；itemN(非必需)为要新增的元素，插入位置即startIndex位置。 1234567const arr6 = [1,2,3,4,5,6,7];const result = arr6.splice(2,2,&quot;a&quot;,&quot;b&quot;);console.log(arr6); //[1,2,&quot;a&quot;,&quot;b&quot;,5,6,7]console.log(result); //[3,4]const result1 = arr6.splice(-2,1,&quot;c&quot;);console.log(arr6); //[1,2,&quot;a&quot;,&quot;b&quot;,5,&quot;c&quot;,7]console.log(result1); //[6] 9、array.indexOf(element,fromIndex)和array.findIndex()indexOf方法可以返回数组中匹配到的给定元素的第一个索引值，若不存在则返回-1。其中element是要匹配的指定元素，fromIndex为开始执行匹配检索的索引位置。 12345const idx = [1,2,3,4,5].indexOf(6);const idx1 = arr.indexOf({name:&quot;洪七公&quot;,alias:&quot;北丐&quot;,age:72})console.log(idx); //-1console.log(idx1); //-1 我们发现对于复杂的对象数组，indexOf是无法进行索引位置查找的 findIndex方法与indexOf方法的作用类似，但更高级，一般用来处理一些复杂的对象数组，查找到则返回第一个匹配元素的索引，反之则返回-1. 1234const idx = arr.findIndex(item =&gt; { return item.name === &quot;洪七公&quot;})console.log(idx) //3 数组的其他处理方法10、array.reverse()reverse方法用来翻转原数组的先后顺序 123const arr = [1,2,3,4,5];arr.reverse();console.log(arr) //[5,4,3,2,1] 11、array.join()join方法用来将数组中的各项元素用某一指定的字符串进行拼接，返回一个新的字符串。 123cosnt arr = [1992,01,12];arr.join(&quot;-&quot;);console.log(arr) //&quot;1992-01-12&quot; 12、array.concat(arr1,arr2,…,arrN)concat为数组拼接方法，可将多个数组进行拼接，最终返回一个新数组，原数组没有改变。 1234const arr = [1,2];const newArr = arr.concat([&quot;a&quot;,&quot;b&quot;],[9,8]);console.log(newArr); //[1,2,&quot;a&quot;,&quot;b&quot;,9,8]console.log(arr); //[1,2] 13、array.sort([copareFunction])sort方法可以对数组按某一指定比较规则进行排序。如果不传参数则按照字符编码的顺序进行排序 14、array.reduce(function(prev,cur,indedx,arr),initialValue)reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。一般来说空数组是不会进行回调的，用空数组执行reduce方法时会报错，但如果设置了初始值则可以避免，但一般也不推荐(因为没有意义)。 initialValue是可自定义的初始值，如果设置了则以其作为初始值（此时起始所以为0），如果不设置则以数组的第一个元素作为初始值（此时起始索引为1）。如下面的2个累加计算示例可看出来 123456const arr = [1,2,3,4]const val = arr.reduce((prev,cur,index,arr) =&gt; { console.log(index) //依次为1,2,3 return prev + cur;})console.log(val) //10 123456const arr = [1,2,3,4]const val = arr.reduce((prev,cur,index,arr) =&gt; { console.log(index) //依次为0,1,2,3 return prev + cur;})console.log(val) //10 reduce方法可以说是一个高级方法，因为他的可自定义的累加器函数，可以处理很多比较高级的操作，常见的有： 数组去重123456789let arr = [1,2,3,3,1,2]let newArr = arr.reduce((pre,cur)=&gt;{ if(!pre.includes(cur)){ return pre.concat(cur) }else{ return pre }},[])console.log(newArr);// [1, 2, 3] 计算数组中各元素出现的次数1234567891011let characters = [&apos;a&apos;, &apos;b&apos;, &apos;t&apos;, &apos;t&apos;, &apos;a&apos;,&apos;f&apos;];let arr = characters.reduce((pre,cur)=&gt;{ if(cur in pre){ pre[cur]++ }else{ pre[cur] = 1 } return pre},{})console.log(arr); //{a: 2, b: 1, t: 2, f: 1} 对象数组中的单个属性累加12345678910const achievement = [ {year:&apos;2016年&apos;,number: 231200}, {year:&apos;2017年&apos;,number: 201900}, {year:&apos;2018年&apos;,number: 275678}, {year:&apos;2019年&apos;,number: 301200}];const sum = achievement.reduce((prev,cur) =&gt; { return prev + cur.number},0)console.log(sum) //1009978 将二维数组转化为一维数组12345let arr = [[0, 1], [2, 3], [4, 5]]let newArr = arr.reduce((pre,cur)=&gt;{ return pre.concat(cur)},[])console.log(newArr); // [0, 1, 2, 3, 4, 5] 将多维数组转化为一维数组12345let arr = [[0, 1], [2, 3], [4,[5,6,7]]]const newArr = function(arr){ return arr.reduce((pre,cur)=&gt;pre.concat(Array.isArray(cur)?newArr(cur):cur),[])}console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7]","link":"/2019/10/31/array-sum/"},{"title":"那些年 那些诗","text":"闲来无事，跟朋友谈天时无意中提到了QQ，懵的一想，好像自去年换工作后，就没怎么去登录过QQ了，上面的动态也很久没有更新过，就奔着回忆的心思去翻看下以前的记忆点滴，当不时的浏览过那些自己曾经写下的诗词时，突然发现，原来那些年，自己也曾那么青春年少，恣意风流。。。 收拾下心情，去重温下那些年的挥洒写意，和青春轨迹吧！ 最近的一首是写于去年春节返家途中，在高铁上遐思所作： 归途 2019年1月28日千灯坠归程，窗外不闻风。揽却一腔思绪，辞别旧岁中.前路几回眸，长空月依旧。怎奈路遥难鉴，拂袖踏歌行！ 当时的自己面临着人生的一个转折点，在第一家公司工作了三年多，仍看不到希望，工作内容也不适合自己，已经有了离职的心思。但面临当前的形势，在考虑是否离职时，心里还是有过一份犹豫，怕下一家还不如当前。但现在看来，自己的决定时正确的，在一个不合适的位置呆了这么久，视野和思维也会被局限住，永远不知道这条路以外的风景是什么样的，跨出这条路，或许就是不一样的风光！ 往前一首是应该算是伪现代诗吧 街头漫步随笔 2016年4月5日清晨的喧嚣，难觅一点静谧。凌乱的思绪，绕成一指回忆。曾几何时，不问前路崎岖，曾几何时，哪顾身后欢喜。不记得，何时习惯了生死别离。不记得，何时默然了弦歌雅意。人生这段路还在延续，命运这首曲一如往昔。韶华已逝，流年依然。不忘初心，吾心即安。 突然发现二首之间，好像隔了好久，这是在毕业那年在上海培训前端工程师的时候写的，面临毕业的关口，我没有选择考研这条路，既有对自己真实情况的考量，也有对自己以后人生规划的抉择，最终我选择了去培训，成为一名IT工作者，而写这首诗不久前，又有一位亲人离去了，貌似在进入大学以后，渐渐的就会不时的面临这种生与死的别离，写这首诗歌，既是对自己前路的一种慰藉和自我鼓励，也算是对已逝亲人寄托一份哀思吧！ 再往前，大学时代，应该是自己文思泉涌的爆发期吧，这四年，因为自己对文学的钟爱，诗词歌赋，历史小说，都在自己愿意去为之痴迷的范围内！ 图书馆休憩小作 2015年9月11日漫吟东风凉，小憩汗浸裳。窗透千枝绿，笔润万卷香。前日迷归途，蹉跎不思量。朝拥镜花醉，暮戏水月忙。谁惜江郎梦，莫道气短长。惟愿路漫漫，誓不回头望。 这个小诗时自己在图书馆临窗自习时所作，权当消遣，也有对自己当时心绪的一种映射。 随笔 2014年8月23日游子从来念故乡，六月离家渡寒江。窗前絮飞应依旧，院里无花可曾香。江左烟雨繁华近，奈何处处是吴音。但逢夜半新雨起，家山梦里问短长。 这首记不清自己因为什么而写的了，总归是首思乡诗。 辞旧岁 2014年6月3日一语一岁留，一枕清梦来年秋。今时欢语犹咫尺。任时光回眸，天涯卧雪，一醉方休。 生日有感随笔。 驻江远望扬州有思 2013年8月29日一水东流，过眼扬州。遥看烟花三月，近观咫尺楼头。谁可天涯携同舟。凭风青衫舞，借水万里舟。不恋一飞冲天劲，但历沧桑万事囚。一梦无忧。 这首词好像是自己在学校后门看江水时作的，原来当时的自己也曾豪气冲天，恣意潇洒过！ 听雨 2013年7月23日晨起雨惊至，蝉窜雀倾翅。饶是檐下落雨帘。雨打青石，溅千前般丝。往昔朝暮醉，荏苒不思量。懒将倦思付一梦，且拾卷册嗅墨香。莫理昨日殇。 这首是大二暑假在家时所作，早晨落雨，借着大地作纸，万千雨声作笔，一蹴而就（其实废了不少脑汁） 闲赋暇思 2013年6月26日绿影翻飞十里风，水润地暗似泉鸣。背倚白杨听风吟，那年幽语此林中。 这首应该是在田间浇地时所作，随短小，但胜在通俗易懂，又不落俗套，个人觉得很有韵味。 无题 2013年6月17日从来痴人多闲愁，拌惹红尘寻烦忧。不如高枕凌烟阁，曲随心动任江流。 无题 2013年6月3日心系魂牵刀剑笑，一离江湖万事轻。甘卧凡尘求一醉，从今江边寻梦人。 这个诗如其名，不知所起，不知所云，为赋新词而作。 听雪小记 2013年2月4日懒理枕旁一尺梦，漫卷诗书思成空。又是一夜风雪动，乱惹枝头点点青。 梦醒随记 2013年2月3日风散雨微寒，梦归意正酣。错落千枝乱，飘零又岁燃。有心未寻梅，无意思踏雪。又恐惹风怒，披雪腊月天。 元旦随笔 2013年1月1日北风狂，何时复北翔？岁来碌碌终无事，闲惹孤影对长江。月临一地霜。虚度日，纵匆忙，羁旅三月为哪桩！若无意执春秋笔，愧对少年殤。 醒梦 2012年11月30日昔日苍狼徒啸月，今朝潜龙伏日眠。忍得九载轮回苦，再赴沧海遨九天！ 随笔 2012年10月23日弦断音绝他年雪，绿绮不响凤求凰。偶拾花香风起处，青海泛波弄潮郎。 随笔 2012年9月12日青春正好，莫道伊行早。繁花碧空青雨，刹那芳华红颜老。一曲狂歌风里绕，轻舟独帆长笑。从来自逍遥，任天地老！ 随笔 2012年7月24日乡雨欲来风盈院 如帘似幕几家看。 恰逢万户眉梢月 半刻雨歇笑驻颜。 随笔 2012年7月20日一朝酒醉柳絮重 半分迟暮夜雨轻. 从今不复少年趣 观罢星火再沐风。 随笔 2012年7月5日一言难尽昨日事,两语易揭飞雪天.三生石畔影常在,五月花谢人可来? 无题 2012年7月4日天涯留梦,童山遗醉,青春踏过云烟净。扯弦几人听,弄舟缺青影。送波往,我自掌歌逍遥行。 独吟 2012年4月22日恨他年闲捉月,笑今朝抱夜孤眠。星河千尺锁两岸。夏风吹几许,谁携尺素还?静磨剑待狼烟,常倚栏望断千川。一任群芳千般好,晓月人独立,犹忆汝河边。 满江红 感高考前七十二天记 2012年3月26日旧歌碎梦，拂晓起，书声喧哗。手起处，执笔如风，心若奔马。他年兵败恰十八，今岁血耻扫浮夸。那堪复、披当年凉月，泪欲擦。九州路，漫无涯。伤心事，不提它。仗青春正好，横刀跃马。此心俯瞰龙虎壤，吾志势破浩中华。今朝起，持九尺青锋，剑歌当下！ 随笔 2011年12月29日十年寒窗伴孤灯，千星寥落日月行。一纸锁尽千日苦，悔把年华付秋风。 闲赋 2011年12月8日天涯置相思 长空寄离愁。谁解人独坐 心已千里游。 闲赋 2011年11月2日从来不知身是客 何必甘居珠峰边一朝战破万般境 桃李千株我争先 爱锁今夏 2011年11月2日阁夜星滴泪，旭日藏旧楼。宁隔千重雨，思化绕指柔。 雨中吟 2011年7月26日雨落无花随风闹 稚避高檐犬吠哓不盼晴空千万里 宁借风雨扫凡尘 无题 2011年7月25日人道年华似水流 我言青春若飞舟轻帆扬逸碧波起 不入青海不识愁 无题 2011年7月25日风卷烈日昏 念得客独省蒙蒙欲睡去 待问梦中人 再往前，那些诗，那些诗，很多都记不得写它的初衷，但里面铭记的，有青涩的爱情，有少年的豪情；有文人的挥洒恣意，有学子的笔下风流。有些甚至现在我都怀疑是出自我自己的笔尖，如果现在让我再执笔，是否还会有当时的文思泉涌呢？或许没有了吧 是不是只有那段青春，才拥有那些不羁的文笔？是不是只有那段岁月，才能填满少年人的沟壑？ 而踏入了社会，渐渐地，我们没有了那份无所顾忌，要为了工作夜以继日；没有了那份闲情逸致，要为了薪资的升降而兢兢业业。那份青春的舒适和坦然，渐行渐远，那份少年的豪情和潇洒，深埋心间。是啊，那段时光已经无法回去，那段记忆也无法重新经历，现在能做的，就是好好的生活，努力的提升自己的生活质量，只有这样，或许在十年后，二十年后，我们还能重拾那段岁月的遗辉，让其在我们的笔下、眉梢、心尖再次绽放！ 那些年，那些诗，或许是这辈子的青春里最璀璨的一抹流光！我不想这流光转瞬即逝，那么，就将其置在手心，时时拂拭，在往后的岁月中，一如过去，挥洒恣意，青春不死！","link":"/2020/04/06/ThatPoems/"},{"title":"深拷贝和浅拷贝","text":"在项目中初次碰到深拷贝和浅拷贝的问题场景是这样的：一个数据注册的信息初始化模板（注册字段比较多），在初始化页面是需要拷贝这个信息模板来初始化页面，本来复制一下是没什么的，但鉴于中间某些操作需要再次使用该信息模板，但因为之前拷贝后对部分值做了修改，导致原信息模板值也同时发生了改变，这才发现拷贝是存在深拷贝和浅拷贝的区别的。 深拷贝和浅拷贝的区别在哪里呢？在介绍深浅拷贝的区别之前，我们先讲解几个前置概念，方便我们更好的理解深浅拷贝的差异。 一、数据类型的分类js的数据类型大体分为两类： 121、基础数据类型：Number,String,Undefined,Null,Boolean,Symbol。这些类型的数据可以直接操作保存在变量中的实际值。2、引用数据类型：Object，Array,Function，可以说除了基础数据类型之外的都属于引用数据类型。 二、栈和堆栈会自动分配内存空间，且会自动释放，它的空间大小是固定的，一般用来存放基础数据类型，简单的数据段。 堆是动态分配的内存空间，大小不固定且不会自动释放。一般用来存放引用数据类型。 我们看下面的一个例子: 123456let a = [1, 2, 3, 4, 5]let b = a;let c = a[0];b[1] = 100;c = 20;console.log(a); //[1,100,3,4,5] 结合上例打印结果可知：a是一个数组，属于引用数据类型，将其赋值给b，实际上是将其引用地址拷贝一份传给了b并存放到栈中，而真实的数组对象则是存放在堆中，系统通过引用地址（或者说指针）来快速查找保存到堆内存中的对象，所以修改数组b就等同于修原数组a。而c只是从a的堆内存中获取了几个基础类型数据拷贝给a,然后将该备份存放到栈内存中，此时该备份与原数据是相互独立的个体，修改c将直接修改栈内存中的值，与a无关。 总的来说就是：简单数据类型直接储存在栈内存中，可以直接访问并对其进行修改；而引用数据类型则是存放在堆内存中，保存在栈内存中的变量其实是一个引用地址（或者说指针）,该指针指向堆内存中存放的对象数据，可以通过指针来查找保存在堆内存中的对象。而拷贝引用数据类型就是拷贝指针，因为拷贝后的指针指向的是同一个对象，所以修改任何一个变量都会修改堆内存中的对象。 如果上述语言过于文字化，我们再举个例子：栈内存就好比一个书橱，每个格子里面存放一本书（也就是基础类型数据），我们要拷贝一份就好比重新印刷一本然后放到下一个空格子里面，二者相互独立，互不相干。堆内存就好比一个大仓库，这些仓库又分许多区，区的大小不一致，每个区都存放某一类书籍，数量不固定，种类不固定(好比引用数据类型的对象和或数组，大小不确定)。为了给对应的区进行分类，我们给每个区一个编号球，然后将编号球放在书橱里，想去查找仓库某个区的书籍时就通过编号快速查询。而拷贝引用数据类型，鉴于其占用内存的大小说不准，为了节约空间，我们就把其编号球复制一个，放到新的书格子里，这样因为他们对应共同的区编号，都可以找到并查看区里的书籍。这样是不是就很好理解了？ 讲了上面2个概念，我们再回头来看深拷贝和浅拷贝，就不会显得没有头绪了。 所谓浅拷贝就是仅仅拷贝基本数据类型，而对于引用数据类型，因为拷贝的只是其引用地址，拷贝后的引用类型数据源发生改变，就意味着原数据源也同时发生了改变。 而深拷贝就是拷贝之后相当于重新开辟出一个内存空间来存放复制的对象，二者相互独立，内容相同但各自占用一个独立内存空间。 常见的浅拷贝方法1、slice大家知道slice()方法可以用来操作一个数组从中截取一段数据形成一个新数组返回。如果不传值，则相当于复制了一个相同的数组并返回。如下所示： 1234let a = [1,2,3,4,5];let b = a.slice();b[0] = 100;console.log(a); //[1,2,3,4,5] 2、concatconcat()也是数组的一个处理方法，用于将两个或多个数组拼接为一个新的数组并返回，而不会改变原数组。如下所示： 1234let a = [1,2,3,4,5];let b = a.concat();b[0] = 100;console.log(a); //[1,2,3,4,5] 3、遍历数组的各项元素，组成一个新数组，这个就不做详述。备注：以上方法都是数组的拷贝，下面2个是对象的拷贝。 4、Object.assign()Object.assign()方法用于合并对象，即将所有可枚举属性的值从一个或多个源对象复制到目标对象，最终返回目标对象。 如果源对象中有和目标对象同名的属性，则后者会覆盖前者，例如： 123456const o1 = { a: 1, b: 1, c: 1 };const o2 = { b: 2, c: 2 };const o3 = { c: 3 };const obj = Object.assign({}, o1, o2, o3);console.log(obj); // { a: 1, b: 2, c: 3 } 但鉴于Object.assign()拷贝时拷贝的是属性值，假如源对象的属性值是一个对象的引用，那么它只能指向那个引用。所以它不能实现深拷贝。 5、扩展运算符扩展运算符可以在函数调用和数组构造时，将数组表达式和string在语法层面上展开，或将对象以key-value的形式展开来。 12345678910//示例一let a = [1,2,3];function add(x,y,z){ return x+y+z}console.log(add(...a)); //6//示例二let c = [...a]; //也可以实现数组的复制let d = {...{a:1,b:2}} //可以实现对象的复制 但如果上述数组和对象中的属性包含其他数组或对象时，这时候复制的依旧是其对应引用地址，所以也无法实现深拷贝。 如何实现深拷贝？1、最通用的方法就是下面这种： 1JSON.parse(JSON.stringify(obj)) 该方法可以轻松的实现深拷贝。2、鉴于上面列举的方法无法实现深拷贝的原因是对于引用类型的数据无法直接拷贝值而是拷贝其引用地址，那么我们对每个引用类型的数据做层层循环遍历处理，也可以达到深拷贝的目的，以下是网上提供的方法： 1234567891011function copy (obj) { var newobj = obj.constructor === Array ? [] : {}; if(typeof obj !== &apos;object&apos;){ return; } for(var i in obj){ newobj[i] = typeof obj[i] === &apos;object&apos; ? copy(obj[i]) : obj[i]; } return newobj} 总结最后我们要知道：深拷贝实际上是很耗性能的，因为它将会把原对象的内容进行复制然后开辟出一块全新的内存空间来进行存放，这样如果对象数据量大而拷贝次数过多，对性能就会产生影响。","link":"/2019/10/31/copy-sum/"},{"title":"周末漫语","text":"距离周末还有不到三个小时的时间，手上的前端任务也早已完成，在等待后端对接的闲暇时间里，开始继续捣鼓自己的个人博客。 时光荏苒，眨眼间毕业已三年，27岁，距而立之年也不再那么遥不可及。当初还略显稚嫩的脸庞也渐渐被一日不理便要侵占半壁江山的胡渣所霸占；与昔日伙伴言谈间的话题里，也渐渐多了车、房、婚姻、钱这些字眼;爸妈的额头、眼角亦是日复一日的被岁月浸染。。。很多迹象都在不经意间向自己透漏着这么个信息————青春渐远！ 记不得自己当初是为什么选择了程序猿这个行当，或许是因为考研未果另谋出路的最优选择（毕竟IT在那会是个很火的词汇），或许是个人性格促使自己觉得跟这个行当很搭，也或许是觉得把一个个字母，字节随着自己指尖轻敲，最终在屏幕上渲染出神奇的画像有一种浓浓的成就感。。。或许以上原因都有，就这么成了编码大军的一员。 后悔吗？ 这个问题似乎很多余，因为自己脑海里确实从来没跳过这个字眼。如果非要说有，可能不是因为自己做出的这个选择，而是在做出选择后没有去认真的对待，所以，三年，虽然一直想去搭建一个个人博客，去记录自己的心情，技术积累，却被自己一拖再拖。直到一个月前，闲余时间较多的情况下，才静下心借助hexo搭建了一个自己的博客。对IT生涯来说，确实有点晚，但对人生来说，总归还不算太晚！可能自己就是一个略显惫懒的性子，心思多且杂，反而很难沉下心去专注于一件事情。 记得大学时代的527，包子是江西人，健谈，善交际，集体活动很活跃，交际中游刃有余，平时的爱好是打游戏;小青跟我是老乡，年龄最小,刚入学那会还不到18岁，戴个眼镜，脑子很活，给人人小鬼大的感觉，除了学业唯一的爱好就是看看美剧；教授是湖北人，是那种放到聊斋里能跟狐仙发生一段人妖孽缘的书生形象，远观的时候文质彬彬，很有儒雅气质，但其实班里大多不雅的外号都缘出他口，除了学习外唯一的爱好就是看看小说；而我，呵呵，相对他们来说貌似是个”全才”,我是游戏，影视，小说都去涉猎的全能型人物，低调，安静，不喜出风头,更多时间沉浸在自己的江湖里，也许是大学之前的业余爱好太少，在进入大学无人管束的环境下，开始大肆的碰触那些之前望而止步的禁地，比如————游戏！这个玩意一直纠缠到现在，还是我生活中不可或缺的一部分。但不知怎么的，近一段时间渐渐提不起兴趣，总是登录上去后一会就感到很空洞无聊，然后默默的退出。回想三年的时光，耗在虚拟江湖的时间已不可计量，如果那些时间用来做别的事情，自己现在会不会更有成就一些呢？三年的轨迹会不会更波澜壮阔一些呢？ 可惜！没有如果！ 人生的每一段经历都是有价值的，我们也不知道在哪个人生节点上，这段经历就会给我们提供不可预料的受益！但也可能永远也用不上，毕竟有些经历能提取的价值是有限的！ 貌似扯远了，既然三年的时光已无法挽留，那就从搭建博客的这一刻开始，收拾起懒散的性子，整理好生活的态度，一点一滴的去泼洒不一样的人生轨迹吧！至少不待对得起自己一直标榜的文艺青年的标签嘛！ 谁言春尚早，非是过来人！揽镜唯自照，始觉已秋分。","link":"/2019/11/22/fllow-heart/"},{"title":"vue组件封装之下拉列表","text":"最近接触app开发，采用了uniapp框架平台，在分析项目需求的时候，发现app端很多功能版块都需要进行组件化封装来达到多方使用的效果，今天就先介绍一个协同下拉列表的开发过程，以及里面所踩到的坑。","link":"/2019/12/19/component-1/"},{"title":"vue-cli项目中mockjs使用说明","text":"前序当前项目开发工作的主流方式是前后端分离，这样在某种程度上可以使前后端各司其职，提高效率。但在项目起步阶段，后端接口尚未提供，而前端在先行开发界面时很多时候需要模拟一些假数据以便于展示，走通流程。我想大部分前端都尝试过先配置一个json文件，填充一些假数据进去来调用模拟后台返回数据。当然，这种造数据的方式是很枯燥的，数据也不够灵活。现在我们有了更好的选择，就是mockjs. mockjs最好用的地方就在于它能够拦截ajax请求，并能更加方便的为你动态模拟假数据。 准备工作vue-cli项目搭建完成后，需先行安装axios和mockjs 12npm install axios --savenpm install mockjs --save-dev 在项目目录中新增mock/index.js路径文件，用以配置mock模拟数据的格式等,接下来先示范一下基础用法： 12345678910111213141516171819import Mock from &quot;mockjs&quot;;const Random = Mock.Random; //Mock.Random是一个工具类，用于产生各种随机数据const usualTemplate = { status: 200, data: { message: &quot;基础信息模板展示&quot; }}Mock.setup({ timeout: &apos;500&apos;})Mock.mock(&apos;/user/list&apos;, usualTemplate);export default Mock; 然后在main.js文件中引入mockjs 123......import &quot;./mock&quot;...... 到此时，mockjs的安装及配置等准备工作已完成。 mock语法简述在index.js文件中，我们在引入mockjs后，有使用Mock.mock()方法，该方法用以设置模拟数据的数据模板，基础语法即： 1Mock.mock(url,template) 其中template模板可以是一个对象或字符串,url是要拦截的ajax请求地址，只要匹配到对应的url字符串即可以进行拦截调用。如下示例 12345678910111213141516171819import Mock from &quot;mockjs&quot;;const Random = Mock.Random; //Mock.Random是一个工具类，用于产生各种随机数据const usualTemplate = { status: 200, data: { message: &quot;基础信息模板展示&quot; }}Mock.setup({ timeout: &apos;500&apos;})Mock.mock(&apos;/user/list&apos;, usualTemplate);export default Mock; 在任意一个视图组件中进行如下调用即可： 1234567891011121314151617&lt;script&gt;import axios from &quot;axios&quot;;export default { data() { return {}; }, mounted() { this.testMock1(); }, methods: { testMock1() { axios.post(&quot;/user/list&quot;).then(res =&gt; { console.log(res); }); } }}; 在控制台打印出返回的结果如下图所示: 我们可以看到，mock返回了一套比较规范的数据返回模板，当然仅仅是这样的话，与我们之前采用json模板没多大区别，反而要引入配置似乎又显得复杂了。 mock.Random工具类其实，mock的便利当然不止这些，里面最常用且最方便的是其提供的一个Mock.Random工具类，它可以用于生成各种数据。 常见的随机数据如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Mock.mock({ //basic &apos;boolean&apos;: Random.boolean(), // 返回一个随机的布尔值。 &apos;natural&apos;: Random.natural(1, 100), // 返回一个随机的自然数（大于等于 0 的整数） &apos;integer&apos;: Random.integer(1, 100), // 生成1到100之间的整数 &apos;float&apos;: Random.float(0, 100, 0, 5), // 生成0到100之间的浮点数,小数点后尾数为0到5位 &apos;character&apos;: Random.character(), // 生成随机字符,可加参数定义规则 &apos;string&apos;: Random.string(&apos;壹贰叁肆伍陆柒捌玖拾&apos;, 3, 5),//返回一个随机字符串。 &apos;range&apos;: Random.range(0, 10, 2), // 生成一个随机数组 //date &apos;date&apos;: Random.date(&apos;yyyy-MM-dd&apos;), // 生成一个随机日期,可加参数定义日期格式 &apos;time&apos;: Random.time(&apos;HH:mm:ss&apos;), //获取一个随机时间 &apos;datetime&apos;: Random.datetime(), // 返回一个随机的日期和时间字符串。 &apos;now&apos;: Random.now(), // 返回当前的日期和时间字符串。 //image &apos;image&apos;: Random.image(&apos;200x100&apos;, &apos;#00405d&apos;, &apos;#FFF&apos;, &apos;Mock.js&apos;),//生成一个随机的图片地址。 &apos;dataImage&apos;: Random.dataImage(Random.size, &apos;hello&apos;),//生成一段随机的 Base64 图片编码。 //color &apos;color&apos;: Random.color(),//随机生成一个有吸引力的颜色，格式为 &apos;#RRGGBB&apos;。 &apos;hex&apos;: Random.hex(), //随机生成一个有吸引力的颜色，格式为 &apos;#RRGGBB&apos;。 &apos;rgb&apos;: Random.rgb(), //随机生成一个有吸引力的颜色，格式为 &apos;rgb(r, g, b)&apos;。 &apos;rgba&apos;: Random.rgba(), //随机生成一个有吸引力的颜色，格式为 &apos;rgba(r, g, b, a)&apos;。 &apos;hsl&apos;: Random.hsl(), //随机生成一个有吸引力的颜色，格式为 &apos;hsl(h, s, l)&apos;。 //text &apos;paragraph&apos;: Random.paragraph(3, 7), // 随机生成一段文本。 &apos;cparagraph&apos;: Random.cparagraph(1, 3), // 随机生成一段中文文本。 &apos;sentence&apos;: Random.sentence(1, 3), // 随机生成一个句子，第一个单词的首字母大写。 &apos;csentence&apos;: Random.csentence(1, 3),// 随机生成一段中文文本。 &apos;word&apos;: Random.word(1, 3),// 随机生成一个单词。 &apos;cword&apos;: Random.cword(&apos;零一二三四五六七八九十&apos;, 10, 15),//生成中文10到15个 &apos;title&apos;: Random.title(3, 5), // 随机生成一句标题，其中每个单词的首字母大写。 &apos;ctitle&apos;: Random.ctitle(3, 7), // 随机生成一句中文标题。 //name &apos;first&apos;: Random.first(),// 随机生成一个常见的英文名。 &apos;last&apos;: Random.last(),// 随机生成一个常见的英文姓。 &apos;name&apos;: Random.name(),// 随机生成一个常见的英文姓名。 &apos;cfirst&apos;: Random.cfirst(),// 随机生成一个常见的中文名。 &apos;clast&apos;: Random.clast(), // 随机生成一个常见的中文姓。 &apos;cname&apos;: Random.cname(),//随机生成一个常见的中文姓名。 //web &apos;url&apos;: Random.url(&apos;http&apos;, &apos;baidu.com&apos;), // 随机生成一个 URL。 &apos;protocol&apos;: Random.protocol(), //随机生成一个 URL 协议 &apos;domain&apos;: Random.domain(), //随机生成一个域名。 &apos;tld&apos;: Random.tld(), //随机生成一个顶级域名 &apos;email&apos;: Random.email(&apos;qq.com&apos;),//随机生成一个邮箱 &apos;ip&apos;: Random.ip(),//随机生成一个 IP 地址。 //address &apos;region&apos;: Random.region(),//随机生成一个（中国）大区。 &apos;province&apos;: Random.province(),//随机生成一个（中国）省（或直辖市、自治区、特别行政区） &apos;city&apos;: Random.city(true),//布尔值。指示是否生成所属的省。 &apos;county&apos;: Random.county(true),//随机生成一个（中国）县。 &apos;zip&apos;: Random.zip(),//随机生成一个邮政编码（六位数字） &apos;address&apos;: Random.province(), // 生成地址 //helper &apos;capitalize&apos;: Random.capitalize(&apos;hello&apos;),//把字符串的第一个字母转换为大写。 &apos;upper&apos;: Random.upper(&apos;hello&apos;),//把字符串转换为大写。 &apos;lower&apos;: Random.lower(&apos;HELLO&apos;),//把字符串转换为小写。 &apos;pick&apos;: Random.pick([&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;]),//从数组中随机选取一个元素，并返回。 &apos;shuffle&apos;: Random.shuffle([&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;]), //打乱数组中元素的顺序，并返回。 //miscellaneous &apos;guid&apos;: Random.guid(), //随机生成一个 GUID。 &apos;id&apos;: Random.id(), //随机生成一个 18 位身份证。 &apos;increment&apos;: Random.increment(2), //生成一个全局的自增整数。自增为2 }) 我们可以借助这个工具类，产生我们所需要的差不多一切数据，免除了自己制造假数据又想让假数据尽量逼真的枯燥过程。 Mock.setup(settings)另外我们提一下setup这个方法，为了使模拟地址拦截数据回调的效果更加逼真，可以通过该方法指定被拦截的ajax请求的拦截时间，单位是毫秒。值可以是正整数，也可以是以斜杠分隔的一个区间。如： 12Mock.setup({ timeout : 400})Mock.setup({ timeout : &apos;200-600&apos; }) 配置过程中所遇到的坑在配置和使用mock过程中，url地址的配置在官网中是支持使用正则的，之前在vue项目中也正常使用过，但后面自己在写这篇文章的时候使用例子测试时，使用正则来进行地址匹配 1Mock.mock(&apos;/\\/user\\/list/&apos;, usualTemplate) 控制台会报404的错误，最后去掉正则直接以地址的部分字符串做匹配，则可以正常调用，暂时未找出原因，怀疑是vscode的某些配置原因。 最后给出一个常用的返回table数据的生成模板样例：12345678910111213141516171819202122232425262728293031323334import Mock from &apos;mockjs&apos; // 引入mockjsconst Random = Mock.Random // Mock.Random 是一个工具类，用于生成各种随机数据// 模拟获取订单列表export const order_list = (params) =&gt; { let list = [] doCustomTimes(10, () =&gt; { list.push(Mock.mock({ // basic &apos;orderId&apos;: Random.integer(1, 1000000000), &apos;userName&apos;: Random.cname(), // 随机生成一个常见的中文姓名。 &apos;idCard&apos;: Random.id(), // 随机生成一个 18 位身份证。 &apos;contractId&apos;: &apos;YZ-0101-JFGD-201904001&apos;, &apos;carType&apos;: Random.pick([&apos;2017款 朗逸 1.6L 自动风尚版&apos;, &apos;2018款 朗逸 1.6L 自动夏季版&apos;, &apos;2019款 朗逸 1.6L 自动风尚版&apos;]), &apos;frameNumber&apos;: Random.pick([&apos;JF1SH52F69G038254&apos;, &apos;JF1SH52F69G038679&apos;, &apos;JF1SH52F69G036682&apos;]), &apos;rentalCapital&apos;: Random.float(0, 100000, 0, 2) })) }) return { total: 86, data: list }}/** * @param {Number} times 回调函数需要执行的次数 * @param {Function} callback 回调函数 */export const doCustomTimes = (times, callback) =&gt; { let i = -1 while (++i &lt; times) { callback(i) }}","link":"/2019/10/31/mock-sum/"},{"title":"我的第一篇测试博客","text":"挑剑试问心所向，万事只有开头难！ 岱宗夫如何，齐鲁青未了。造化钟神秀，阴阳割分晓。","link":"/2019/10/30/test/"}],"tags":[{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"组件封装","slug":"组件封装","link":"/tags/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"}],"categories":[{"name":"ES6","slug":"ES6","link":"/categories/ES6/"},{"name":"原生JS","slug":"原生JS","link":"/categories/%E5%8E%9F%E7%94%9FJS/"},{"name":"VUE","slug":"VUE","link":"/categories/VUE/"},{"name":"闲散小记","slug":"闲散小记","link":"/categories/%E9%97%B2%E6%95%A3%E5%B0%8F%E8%AE%B0/"}]}