{"pages":[],"posts":[{"title":"ES6常见数组处理方法分析汇总","text":"事先给出一个以下方法要遍历的数组对象： 1234567const arr = [ {name:&quot;黄药师&quot;,alias:&quot;东邪&quot;,age:66}, {name:&quot;欧阳锋&quot;,alias:&quot;西毒&quot;,age:66}, {name:&quot;段皇爷&quot;,alias:&quot;南帝&quot;,age:76}, {name:&quot;洪七公&quot;,alias:&quot;北丐&quot;,age:72}, {name:&quot;王重阳&quot;,alias:&quot;中神通&quot;,age:80}]; 一、遍历数组元素进行某种逻辑判断返回布尔值的数组方法1、array.every()every方法用来检测数组中的每一项元素是否都通过了某一条件判断，通过则返回true，反之返回false 1234const flag = arr.every(item =&gt; { return item.age === 66})console.log(flag) //false 2、array.some()some方法用来检测数组中是否存在至少一项元素满足某一条件判断，存在则返回true，反之则返回false 1234const flag = arr.some(item =&gt; { return item.alias === &quot;北丐&quot;})console.log(flag) //true 3、array.includes(element,fromIndex)includes方法用来判断数组内是否包含某一个指定值，且可以指定从数组某一个索引值开始检索。其中element是要检索的元素，fromIndex是开始检索的索引值。 12const flag = [1,2,3,5].includes(5,2);console.log(flag) //true 二、遍历数组元素并返回一个新数组4、array.map()map方法用来遍历数组中的每一个元素，然后对其做同一处理，返回新的元素最终组合成一个新数组返回。 12345const arr1 = arr.map(item =&gt; { return {alias: `五绝之${item.alias}`}})console.log(arr1) /* [{alias:&quot;五绝之东邪&quot;},{alias:&quot;五绝之西毒&quot;},{alias:&quot;五绝之南帝&quot;},{alias:&quot;五绝之北丐&quot;},{alias:&quot;五绝之中神通&quot;}] */ 5、array.filter()filter方法用来遍历数组中的每一项元素，然后执行同一判断条件的检测后过滤出满足条件的元素值最终组合成新的数组返回。 1234const arr1 = arr.filter(item =&gt; { return item.name === &quot;洪七公&quot;})console.log(arr1); //[{name:&quot;洪七公&quot;,alias:&quot;北丐&quot;,age:72}] 三、数组处理的增删改查6、array.pop()和array.shift()pop方法用来删除数组的最后一个元素，并返回最后一个元素的值。备注：数组为空时则返回undefined 1234const newArr = [1,2,3,4,5];const val = newArr.pop();console.log(newArr); //[1,2,3,4]console.log(val); //5 shift方法用来删除数组的第一个元素，并返回第一个元素的值。备注：数组为空时则返回undefined 1234const newArr = [1,2,3,4,5];const val = newArr.shift();console.log(newArr); //[2,3,4,5]console.log(val); //1 7、array.push(element1,element2,…,elementN)和array.unshift(element1,element2,…,elementN)push方法用来将一个或多个元素依次添加到数组的末尾，并返回新数组的长度。 1234const arr = [1,2,3,4];const len = arr5.unshift(9,8);console.log(arr) //[9,8,1,2,3,4]console.log(len) //6 unshift方法用来将一个或多个元素依次添加到数组的开头，并返回新数组的长度。 1234const arr = [1,2,3,4];const len = arr5.unshift(9,8);console.log(arr) //[1,2,3,4,9,8]console.log(len) //6 8、array.splice(startIndex,deleteItemNum,item1,item2,…,itemN)splice方法可以实现对数组进行增删的操作并返回被删除的项所组成的数组，其中startIndex（必需）是规定要添加/删除元素的位置，若未负数则从末尾处开始；deleteItemNum是要删除的元素个数，若为0则不删除；itemN(非必需)为要新增的元素，插入位置即startIndex位置。 1234567const arr6 = [1,2,3,4,5,6,7];const result = arr6.splice(2,2,&quot;a&quot;,&quot;b&quot;);console.log(arr6); //[1,2,&quot;a&quot;,&quot;b&quot;,5,6,7]console.log(result); //[3,4]const result1 = arr6.splice(-2,1,&quot;c&quot;);console.log(arr6); //[1,2,&quot;a&quot;,&quot;b&quot;,5,&quot;c&quot;,7]console.log(result1); //[6] 9、array.indexOf(element,fromIndex)和array.findIndex()indexOf方法可以返回数组中匹配到的给定元素的第一个索引值，若不存在则返回-1。其中element是要匹配的指定元素，fromIndex为开始执行匹配检索的索引位置。 12345const idx = [1,2,3,4,5].indexOf(6);const idx1 = arr.indexOf({name:&quot;洪七公&quot;,alias:&quot;北丐&quot;,age:72})console.log(idx); //-1console.log(idx1); //-1 我们发现对于复杂的对象数组，indexOf是无法进行索引位置查找的 findIndex方法与indexOf方法的作用类似，但更高级，一般用来处理一些复杂的对象数组，查找到则返回第一个匹配元素的索引，反之则返回-1. 1234const idx = arr.findIndex(item =&gt; { return item.name === &quot;洪七公&quot;})console.log(idx) //3 数组的其他处理方法10、array.reverse()reverse方法用来翻转原数组的先后顺序 123const arr = [1,2,3,4,5];arr.reverse();console.log(arr) //[5,4,3,2,1] 11、array.join()join方法用来将数组中的各项元素用某一指定的字符串进行拼接，返回一个新的字符串。 123cosnt arr = [1992,01,12];arr.join(&quot;-&quot;);console.log(arr) //&quot;1992-01-12&quot; 12、array.concat(arr1,arr2,…,arrN)concat为数组拼接方法，可将多个数组进行拼接，最终返回一个新数组，原数组没有改变。 1234const arr = [1,2];const newArr = arr.concat([&quot;a&quot;,&quot;b&quot;],[9,8]);console.log(newArr); //[1,2,&quot;a&quot;,&quot;b&quot;,9,8]console.log(arr); //[1,2] 13、array.sort([copareFunction])sort方法可以对数组按某一指定比较规则进行排序。如果不传参数则按照字符编码的顺序进行排序 14、array.reduce(function(prev,cur,indedx,arr),initialValue)reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。一般来说空数组是不会进行回调的，用空数组执行reduce方法时会报错，但如果设置了初始值则可以避免，但一般也不推荐(因为没有意义)。 initialValue是可自定义的初始值，如果设置了则以其作为初始值（此时起始所以为0），如果不设置则以数组的第一个元素作为初始值（此时起始索引为1）。如下面的2个累加计算示例可看出来 123456const arr = [1,2,3,4]const val = arr.reduce((prev,cur,index,arr) =&gt; { console.log(index) //依次为1,2,3 return prev + cur;})console.log(val) //10 123456const arr = [1,2,3,4]const val = arr.reduce((prev,cur,index,arr) =&gt; { console.log(index) //依次为0,1,2,3 return prev + cur;})console.log(val) //10 reduce方法可以说是一个高级方法，因为他的可自定义的累加器函数，可以处理很多比较高级的操作，常见的有： 数组去重123456789let arr = [1,2,3,3,1,2]let newArr = arr.reduce((pre,cur)=&gt;{ if(!pre.includes(cur)){ return pre.concat(cur) }else{ return pre }},[])console.log(newArr);// [1, 2, 3] 计算数组中各元素出现的次数1234567891011let characters = [&apos;a&apos;, &apos;b&apos;, &apos;t&apos;, &apos;t&apos;, &apos;a&apos;,&apos;f&apos;];let arr = characters.reduce((pre,cur)=&gt;{ if(cur in pre){ pre[cur]++ }else{ pre[cur] = 1 } return pre},{})console.log(arr); //{a: 2, b: 1, t: 2, f: 1} 对象数组中的单个属性累加12345678910const achievement = [ {year:&apos;2016年&apos;,number: 231200}, {year:&apos;2017年&apos;,number: 201900}, {year:&apos;2018年&apos;,number: 275678}, {year:&apos;2019年&apos;,number: 301200}];const sum = achievement.reduce((prev,cur) =&gt; { return prev + cur.number},0)console.log(sum) //1009978 将二维数组转化为一维数组12345let arr = [[0, 1], [2, 3], [4, 5]]let newArr = arr.reduce((pre,cur)=&gt;{ return pre.concat(cur)},[])console.log(newArr); // [0, 1, 2, 3, 4, 5] 将多维数组转化为一维数组12345let arr = [[0, 1], [2, 3], [4,[5,6,7]]]const newArr = function(arr){ return arr.reduce((pre,cur)=&gt;pre.concat(Array.isArray(cur)?newArr(cur):cur),[])}console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7]","link":"/2019/10/31/array-sum/"},{"title":"周末漫语","text":"距离周末还有不到三个小时的时间，手上的前端任务也早已完成，在等待后端对接的闲暇时间里，开始继续捣鼓自己的个人博客。 时光荏苒，眨眼间毕业已三年，27岁，距而立之年也不再那么遥不可及。当初还略显稚嫩的脸庞也渐渐被一日不理便要侵占半壁江山的胡渣所霸占；与昔日伙伴言谈间的话题里，也渐渐多了车、房、婚姻、钱这些字眼;爸妈的额头、眼角亦是日复一日的被岁月浸染。。。很多迹象都在不经意间向自己透漏着这么个信息————青春渐远！ 记不得自己当初是为什么选择了程序猿这个行当，或许是因为考研未果另谋出路的最优选择（毕竟IT在那会是个很火的词汇），或许是个人性格促使自己觉得跟这个行当很搭，也或许是觉得把一个个字母，字节随着自己指尖轻敲，最终在屏幕上渲染出神奇的画像有一种浓浓的成就感。。。或许以上原因都有，就这么成了编码大军的一员。 后悔吗？ 这个问题似乎很多余，因为自己脑海里确实从来没跳过这个字眼。如果非要说有，可能不是因为自己做出的这个选择，而是在做出选择后没有去认真的对待，所以，三年，虽然一直想去搭建一个个人博客，去记录自己的心情，技术积累，却被自己一拖再拖。直到一个月前，闲余时间较多的情况下，才静下心借助hexo搭建了一个自己的博客。对IT生涯来说，确实有点晚，但对人生来说，总归还不算太晚！可能自己就是一个略显惫懒的性子，心思多且杂，反而很难沉下心去专注于一件事情。 记得大学时代的527，包子是江西人，健谈，善交际，集体活动很活跃，交际中游刃有余，平时的爱好是打游戏;小青跟我是老乡，年龄最小,刚入学那会还不到18岁，戴个眼镜，脑子很活，给人人小鬼大的感觉，除了学业唯一的爱好就是看看美剧；教授是湖北人，是那种放到聊斋里能跟狐仙发生一段人妖孽缘的书生形象，远观的时候文质彬彬，很有儒雅气质，但其实班里大多不雅的外号都缘出他口，除了学习外唯一的爱好就是看看小说；而我，呵呵，相对他们来说貌似是个”全才”,我是游戏，影视，小说都去涉猎的全能型人物，低调，安静，不喜出风头,更多时间沉浸在自己的江湖里，也许是大学之前的业余爱好太少，在进入大学无人管束的环境下，开始大肆的碰触那些之前望而止步的禁地，比如————游戏！这个玩意一直纠缠到现在，还是我生活中不可或缺的一部分。但不知怎么的，近一段时间渐渐提不起兴趣，总是登录上去后一会就感到很空洞无聊，然后默默的退出。回想三年的时光，耗在虚拟江湖的时间已不可计量，如果那些时间用来做别的事情，自己现在会不会更有成就一些呢？三年的轨迹会不会更波澜壮阔一些呢？ 可惜！没有如果！ 人生的每一段经历都是有价值的，我们也不知道在哪个人生节点上，这段经历就会给我们提供不可预料的受益！但也可能永远也用不上，毕竟有些经历能提取的价值是有限的！ 貌似扯远了，既然三年的时光已无法挽留，那就从搭建博客的这一刻开始，收拾起懒散的性子，整理好生活的态度，一点一滴的去泼洒不一样的人生轨迹吧！至少不待对得起自己一直标榜的文艺青年的标签嘛！ 谁言春尚早，非是过来人！揽镜唯自照，始觉已秋分。","link":"/2019/11/22/fllow-heart/"},{"title":"我的第一篇测试博客","text":"挑剑试问心所向，万事只有开头难！ 岱宗夫如何，齐鲁青未了。造化钟神秀，阴阳割分晓。","link":"/2019/10/30/test/"},{"title":"vue-cli项目中mockjs使用说明","text":"前序当前项目开发工作的主流方式是前后端分离，这样在某种程度上可以使前后端各司其职，提高效率。但在项目起步阶段，后端接口尚未提供，而前端在先行开发界面时很多时候需要模拟一些假数据以便于展示，走通流程。我想大部分前端都尝试过先配置一个json文件，填充一些假数据进去来调用模拟后台返回数据。当然，这种造数据的方式是很枯燥的，数据也不够灵活。现在我们有了更好的选择，就是mockjs. mockjs最好用的地方就在于它能够拦截ajax请求，并能更加方便的为你动态模拟假数据。 准备工作vue-cli项目搭建完成后，需先行安装axios和mockjs 12npm install axios --savenpm install mockjs --save-dev 在项目目录中新增mock/index.js路径文件，用以配置mock模拟数据的格式等,接下来先示范一下基础用法： 12345678910111213141516171819import Mock from &quot;mockjs&quot;;const Random = Mock.Random; //Mock.Random是一个工具类，用于产生各种随机数据const usualTemplate = { status: 200, data: { message: &quot;基础信息模板展示&quot; }}Mock.setup({ timeout: &apos;500&apos;})Mock.mock(&apos;/user/list&apos;, usualTemplate);export default Mock; 然后在main.js文件中引入mockjs 123......import &quot;./mock&quot;...... 到此时，mockjs的安装及配置等准备工作已完成。 mock语法简述在index.js文件中，我们在引入mockjs后，有使用Mock.mock()方法，该方法用以设置模拟数据的数据模板，基础语法即： 1Mock.mock(url,template) 其中template模板可以是一个对象或字符串,url是要拦截的ajax请求地址，只要匹配到对应的url字符串即可以进行拦截调用。如下示例 12345678910111213141516171819import Mock from &quot;mockjs&quot;;const Random = Mock.Random; //Mock.Random是一个工具类，用于产生各种随机数据const usualTemplate = { status: 200, data: { message: &quot;基础信息模板展示&quot; }}Mock.setup({ timeout: &apos;500&apos;})Mock.mock(&apos;/user/list&apos;, usualTemplate);export default Mock; 在任意一个视图组件中进行如下调用即可： 1234567891011121314151617&lt;script&gt;import axios from &quot;axios&quot;;export default { data() { return {}; }, mounted() { this.testMock1(); }, methods: { testMock1() { axios.post(&quot;/user/list&quot;).then(res =&gt; { console.log(res); }); } }}; 在控制台打印出返回的结果如下图所示: 我们可以看到，mock返回了一套比较规范的数据返回模板，当然仅仅是这样的话，与我们之前采用json模板没多大区别，反而要引入配置似乎又显得复杂了。 mock.Random工具类其实，mock的便利当然不止这些，里面最常用且最方便的是其提供的一个Mock.Random工具类，它可以用于生成各种数据。 常见的随机数据如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Mock.mock({ //basic &apos;boolean&apos;: Random.boolean(), // 返回一个随机的布尔值。 &apos;natural&apos;: Random.natural(1, 100), // 返回一个随机的自然数（大于等于 0 的整数） &apos;integer&apos;: Random.integer(1, 100), // 生成1到100之间的整数 &apos;float&apos;: Random.float(0, 100, 0, 5), // 生成0到100之间的浮点数,小数点后尾数为0到5位 &apos;character&apos;: Random.character(), // 生成随机字符,可加参数定义规则 &apos;string&apos;: Random.string(&apos;壹贰叁肆伍陆柒捌玖拾&apos;, 3, 5),//返回一个随机字符串。 &apos;range&apos;: Random.range(0, 10, 2), // 生成一个随机数组 //date &apos;date&apos;: Random.date(&apos;yyyy-MM-dd&apos;), // 生成一个随机日期,可加参数定义日期格式 &apos;time&apos;: Random.time(&apos;HH:mm:ss&apos;), //获取一个随机时间 &apos;datetime&apos;: Random.datetime(), // 返回一个随机的日期和时间字符串。 &apos;now&apos;: Random.now(), // 返回当前的日期和时间字符串。 //image &apos;image&apos;: Random.image(&apos;200x100&apos;, &apos;#00405d&apos;, &apos;#FFF&apos;, &apos;Mock.js&apos;),//生成一个随机的图片地址。 &apos;dataImage&apos;: Random.dataImage(Random.size, &apos;hello&apos;),//生成一段随机的 Base64 图片编码。 //color &apos;color&apos;: Random.color(),//随机生成一个有吸引力的颜色，格式为 &apos;#RRGGBB&apos;。 &apos;hex&apos;: Random.hex(), //随机生成一个有吸引力的颜色，格式为 &apos;#RRGGBB&apos;。 &apos;rgb&apos;: Random.rgb(), //随机生成一个有吸引力的颜色，格式为 &apos;rgb(r, g, b)&apos;。 &apos;rgba&apos;: Random.rgba(), //随机生成一个有吸引力的颜色，格式为 &apos;rgba(r, g, b, a)&apos;。 &apos;hsl&apos;: Random.hsl(), //随机生成一个有吸引力的颜色，格式为 &apos;hsl(h, s, l)&apos;。 //text &apos;paragraph&apos;: Random.paragraph(3, 7), // 随机生成一段文本。 &apos;cparagraph&apos;: Random.cparagraph(1, 3), // 随机生成一段中文文本。 &apos;sentence&apos;: Random.sentence(1, 3), // 随机生成一个句子，第一个单词的首字母大写。 &apos;csentence&apos;: Random.csentence(1, 3),// 随机生成一段中文文本。 &apos;word&apos;: Random.word(1, 3),// 随机生成一个单词。 &apos;cword&apos;: Random.cword(&apos;零一二三四五六七八九十&apos;, 10, 15),//生成中文10到15个 &apos;title&apos;: Random.title(3, 5), // 随机生成一句标题，其中每个单词的首字母大写。 &apos;ctitle&apos;: Random.ctitle(3, 7), // 随机生成一句中文标题。 //name &apos;first&apos;: Random.first(),// 随机生成一个常见的英文名。 &apos;last&apos;: Random.last(),// 随机生成一个常见的英文姓。 &apos;name&apos;: Random.name(),// 随机生成一个常见的英文姓名。 &apos;cfirst&apos;: Random.cfirst(),// 随机生成一个常见的中文名。 &apos;clast&apos;: Random.clast(), // 随机生成一个常见的中文姓。 &apos;cname&apos;: Random.cname(),//随机生成一个常见的中文姓名。 //web &apos;url&apos;: Random.url(&apos;http&apos;, &apos;baidu.com&apos;), // 随机生成一个 URL。 &apos;protocol&apos;: Random.protocol(), //随机生成一个 URL 协议 &apos;domain&apos;: Random.domain(), //随机生成一个域名。 &apos;tld&apos;: Random.tld(), //随机生成一个顶级域名 &apos;email&apos;: Random.email(&apos;qq.com&apos;),//随机生成一个邮箱 &apos;ip&apos;: Random.ip(),//随机生成一个 IP 地址。 //address &apos;region&apos;: Random.region(),//随机生成一个（中国）大区。 &apos;province&apos;: Random.province(),//随机生成一个（中国）省（或直辖市、自治区、特别行政区） &apos;city&apos;: Random.city(true),//布尔值。指示是否生成所属的省。 &apos;county&apos;: Random.county(true),//随机生成一个（中国）县。 &apos;zip&apos;: Random.zip(),//随机生成一个邮政编码（六位数字） &apos;address&apos;: Random.province(), // 生成地址 //helper &apos;capitalize&apos;: Random.capitalize(&apos;hello&apos;),//把字符串的第一个字母转换为大写。 &apos;upper&apos;: Random.upper(&apos;hello&apos;),//把字符串转换为大写。 &apos;lower&apos;: Random.lower(&apos;HELLO&apos;),//把字符串转换为小写。 &apos;pick&apos;: Random.pick([&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;]),//从数组中随机选取一个元素，并返回。 &apos;shuffle&apos;: Random.shuffle([&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;]), //打乱数组中元素的顺序，并返回。 //miscellaneous &apos;guid&apos;: Random.guid(), //随机生成一个 GUID。 &apos;id&apos;: Random.id(), //随机生成一个 18 位身份证。 &apos;increment&apos;: Random.increment(2), //生成一个全局的自增整数。自增为2 }) 我们可以借助这个工具类，产生我们所需要的差不多一切数据，免除了自己制造假数据又想让假数据尽量逼真的枯燥过程。 Mock.setup(settings)另外我们提一下setup这个方法，为了使模拟地址拦截数据回调的效果更加逼真，可以通过该方法指定被拦截的ajax请求的拦截时间，单位是毫秒。值可以是正整数，也可以是以斜杠分隔的一个区间。如： 12Mock.setup({ timeout : 400})Mock.setup({ timeout : &apos;200-600&apos; }) 配置过程中所遇到的坑在配置和使用mock过程中，url地址的配置在官网中是支持使用正则的，之前在vue项目中也正常使用过，但后面自己在写这篇文章的时候使用例子测试时，使用正则来进行地址匹配 1Mock.mock(&apos;/\\/user\\/list/&apos;, usualTemplate) 控制台会报404的错误，最后去掉正则直接以地址的部分字符串做匹配，则可以正常调用，暂时未找出原因，怀疑是vscode的某些配置原因。 最后给出一个常用的返回table数据的生成模板样例：12345678910111213141516171819202122232425262728293031323334import Mock from &apos;mockjs&apos; // 引入mockjsconst Random = Mock.Random // Mock.Random 是一个工具类，用于生成各种随机数据// 模拟获取订单列表export const order_list = (params) =&gt; { let list = [] doCustomTimes(10, () =&gt; { list.push(Mock.mock({ // basic &apos;orderId&apos;: Random.integer(1, 1000000000), &apos;userName&apos;: Random.cname(), // 随机生成一个常见的中文姓名。 &apos;idCard&apos;: Random.id(), // 随机生成一个 18 位身份证。 &apos;contractId&apos;: &apos;YZ-0101-JFGD-201904001&apos;, &apos;carType&apos;: Random.pick([&apos;2017款 朗逸 1.6L 自动风尚版&apos;, &apos;2018款 朗逸 1.6L 自动夏季版&apos;, &apos;2019款 朗逸 1.6L 自动风尚版&apos;]), &apos;frameNumber&apos;: Random.pick([&apos;JF1SH52F69G038254&apos;, &apos;JF1SH52F69G038679&apos;, &apos;JF1SH52F69G036682&apos;]), &apos;rentalCapital&apos;: Random.float(0, 100000, 0, 2) })) }) return { total: 86, data: list }}/** * @param {Number} times 回调函数需要执行的次数 * @param {Function} callback 回调函数 */export const doCustomTimes = (times, callback) =&gt; { let i = -1 while (++i &lt; times) { callback(i) }}","link":"/2019/10/31/mock-sum/"},{"title":"深拷贝和浅拷贝","text":"在项目中初次碰到深拷贝和浅拷贝的问题场景是这样的：一个数据注册的信息初始化模板（注册字段比较多），在初始化页面是需要拷贝这个信息模板来初始化页面，本来复制一下是没什么的，但鉴于中间某些操作需要再次使用该信息模板，但因为之前拷贝后对部分值做了修改，导致原信息模板值也同时发生了改变，这才发现拷贝是存在深拷贝和浅拷贝的区别的。 深拷贝和浅拷贝的区别在哪里呢？在介绍深浅拷贝的区别之前，我们先讲解几个前置概念，方便我们更好的理解深浅拷贝的差异。 一、数据类型的分类js的数据类型大体分为两类： 121、基础数据类型：Number,String,Undefined,Null,Boolean,Symbol。这些类型的数据可以直接操作保存在变量中的实际值。2、引用数据类型：Object，Array,Function，可以说除了基础数据类型之外的都属于引用数据类型。 二、栈和堆栈会自动分配内存空间，且会自动释放，它的空间大小是固定的，一般用来存放基础数据类型，简单的数据段。 堆是动态分配的内存空间，大小不固定且不会自动释放。一般用来存放引用数据类型。 我们看下面的一个例子: 123456let a = [1, 2, 3, 4, 5]let b = a;let c = a[0];b[1] = 100;c = 20;console.log(a); //[1,100,3,4,5] 结合上例打印结果可知：a是一个数组，属于引用数据类型，将其赋值给b，实际上是将其引用地址拷贝一份传给了b并存放到栈中，而真实的数组对象则是存放在堆中，系统通过引用地址（或者说指针）来快速查找保存到堆内存中的对象，所以修改数组b就等同于修原数组a。而c只是从a的堆内存中获取了几个基础类型数据拷贝给a,然后将该备份存放到栈内存中，此时该备份与原数据是相互独立的个体，修改c将直接修改栈内存中的值，与a无关。 总的来说就是：简单数据类型直接储存在栈内存中，可以直接访问并对其进行修改；而引用数据类型则是存放在堆内存中，保存在栈内存中的变量其实是一个引用地址（或者说指针）,该指针指向堆内存中存放的对象数据，可以通过指针来查找保存在堆内存中的对象。而拷贝引用数据类型就是拷贝指针，因为拷贝后的指针指向的是同一个对象，所以修改任何一个变量都会修改堆内存中的对象。 如果上述语言过于文字化，我们再举个例子：栈内存就好比一个书橱，每个格子里面存放一本书（也就是基础类型数据），我们要拷贝一份就好比重新印刷一本然后放到下一个空格子里面，二者相互独立，互不相干。堆内存就好比一个大仓库，这些仓库又分许多区，区的大小不一致，每个区都存放某一类书籍，数量不固定，种类不固定(好比引用数据类型的对象和或数组，大小不确定)。为了给对应的区进行分类，我们给每个区一个编号球，然后将编号球放在书橱里，想去查找仓库某个区的书籍时就通过编号快速查询。而拷贝引用数据类型，鉴于其占用内存的大小说不准，为了节约空间，我们就把其编号球复制一个，放到新的书格子里，这样因为他们对应共同的区编号，都可以找到并查看区里的书籍。这样是不是就很好理解了？ 讲了上面2个概念，我们再回头来看深拷贝和浅拷贝，就不会显得没有头绪了。 所谓浅拷贝就是仅仅拷贝基本数据类型，而对于引用数据类型，因为拷贝的只是其引用地址，拷贝后的引用类型数据源发生改变，就意味着原数据源也同时发生了改变。 而深拷贝就是拷贝之后相当于重新开辟出一个内存空间来存放复制的对象，二者相互独立，内容相同但各自占用一个独立内存空间。 常见的浅拷贝方法1、slice大家知道slice()方法可以用来操作一个数组从中截取一段数据形成一个新数组返回。如果不传值，则相当于复制了一个相同的数组并返回。如下所示： 1234let a = [1,2,3,4,5];let b = a.slice();b[0] = 100;console.log(a); //[1,2,3,4,5] 2、concatconcat()也是数组的一个处理方法，用于将两个或多个数组拼接为一个新的数组并返回，而不会改变原数组。如下所示： 1234let a = [1,2,3,4,5];let b = a.concat();b[0] = 100;console.log(a); //[1,2,3,4,5] 3、遍历数组的各项元素，组成一个新数组，这个就不做详述。备注：以上方法都是数组的拷贝，下面2个是对象的拷贝。 4、Object.assign()Object.assign()方法用于合并对象，即将所有可枚举属性的值从一个或多个源对象复制到目标对象，最终返回目标对象。 如果源对象中有和目标对象同名的属性，则后者会覆盖前者，例如： 123456const o1 = { a: 1, b: 1, c: 1 };const o2 = { b: 2, c: 2 };const o3 = { c: 3 };const obj = Object.assign({}, o1, o2, o3);console.log(obj); // { a: 1, b: 2, c: 3 } 但鉴于Object.assign()拷贝时拷贝的是属性值，假如源对象的属性值是一个对象的引用，那么它只能指向那个引用。所以它不能实现深拷贝。 5、扩展运算符扩展运算符可以在函数调用和数组构造时，将数组表达式和string在语法层面上展开，或将对象以key-value的形式展开来。 12345678910//示例一let a = [1,2,3];function add(x,y,z){ return x+y+z}console.log(add(...a)); //6//示例二let c = [...a]; //也可以实现数组的复制let d = {...{a:1,b:2}} //可以实现对象的复制 但如果上述数组和对象中的属性包含其他数组或对象时，这时候复制的依旧是其对应引用地址，所以也无法实现深拷贝。 如何实现深拷贝？1、最通用的方法就是下面这种： 1JSON.parse(JSON.stringify(obj)) 该方法可以轻松的实现深拷贝。2、鉴于上面列举的方法无法实现深拷贝的原因是对于引用类型的数据无法直接拷贝值而是拷贝其引用地址，那么我们对每个引用类型的数据做层层循环遍历处理，也可以达到深拷贝的目的，以下是网上提供的方法： 1234567891011function copy (obj) { var newobj = obj.constructor === Array ? [] : {}; if(typeof obj !== &apos;object&apos;){ return; } for(var i in obj){ newobj[i] = typeof obj[i] === &apos;object&apos; ? copy(obj[i]) : obj[i]; } return newobj} 总结最后我们要知道：深拷贝实际上是很耗性能的，因为它将会把原对象的内容进行复制然后开辟出一块全新的内存空间来进行存放，这样如果对象数据量大而拷贝次数过多，对性能就会产生影响。","link":"/2019/10/31/copy-sum/"}],"tags":[{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"}],"categories":[{"name":"ES6","slug":"ES6","link":"/categories/ES6/"},{"name":"闲散小记","slug":"闲散小记","link":"/categories/%E9%97%B2%E6%95%A3%E5%B0%8F%E8%AE%B0/"},{"name":"VUE","slug":"VUE","link":"/categories/VUE/"},{"name":"原生JS","slug":"原生JS","link":"/categories/%E5%8E%9F%E7%94%9FJS/"}]}